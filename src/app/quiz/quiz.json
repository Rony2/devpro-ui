[
  {
    "slug": "can-you-offer-a-use-case-for-the-new-arrow-function-syntax-how-does-this-new-syntax-differ-from-other-functions",
    "title": "Can you offer a use case for the new arrow => function syntax?",
    "description": "Arrow functions provide a concise syntax for writing functions in JavaScript. They are particularly useful for maintaining the `this` context within methods and callbacks. For example, in an event handler or array method like `map`, arrow functions can simplify the code and avoid issues with `this` binding."
  },
  {
    "slug": "describe-event-bubbling",
    "title": "Describe event bubbling in JavaScript and browsers",
    "description": "Event bubbling is a DOM event propagation mechanism where an event (e.g. a click), starts at the target element and bubbles up to the root of the document. This allows ancestor elements to also respond to the event."
  },
  {
    "slug": "describe-event-capturing",
    "title": "Describe event capturing in JavaScript and browsers",
    "description": "Event capturing is a lesser-used counterpart to [event bubbling](/questions/quiz/describe-event-bubbling) in the DOM event propagation mechanism. It follows the opposite order, where an event triggers first on the ancestor element and then travels down to the target element."
  },
  {
    "slug": "describe-the-difference-between-a-cookie-sessionstorage-and-localstorage",
    "title": "Describe the difference between a cookie, `sessionStorage` and `localStorage` in browsers",
    "description": "All of the following are mechanisms of storing data on the client, the user's browser in this case. `localStorage` and `sessionStorage` both implement the [Web Storage API interface](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)."
  },
  {
    "slug": "describe-the-difference-between-script-async-and-script-defer",
    "title": "Describe the difference between `<script>`, `<script async>` and `<script defer>`",
    "description": "All of these ways (`<script>`, `<script async>`, and `<script defer>`) are used to load and execute JavaScript files in an HTML document, but they differ in how the browser handles loading and execution of the script:"
  },
  {
    "slug": "difference-between-document-load-event-and-document-domcontentloaded-event",
    "title": "Difference between document `load` event and document `DOMContentLoaded` event?",
    "description": "The `DOMContentLoaded` event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. The `load` event, on the other hand, fires when the entire page, including all dependent resources such as stylesheets and images, has finished loading."
  },
  {
    "slug": "difference-between-function-person-var-person-person-and-var-person-new-person",
    "title": "Difference between: `function Person(){}`, `const person = Person()`, and `const person = new Person()` in JavaScript?",
    "description": "| Aspect | `function Person(){}` | `const person = Person()` | `const person = new Person()` |\n| --- | --- | --- | --- |\n| Type | Function declaration | Function call | Constructor call |\n| Usage | Defines a function | Invokes `Person` as a regular function | Creates a new instance of `Person` |\n| Instance Creation | No instance created | No instance created | New instance created |\n| Common Mistake | N/A | Misusing as constructor leading to `undefined` | None (when used correctly) |"
  },
  {
    "slug": "explain-ajax-in-as-much-detail-as-possible",
    "title": "Explain AJAX in as much detail as possible",
    "description": "AJAX (Asynchronous JavaScript and XML) facilitates asynchronous communication between the client and server, enabling dynamic updates to web pages without reloading. It uses techniques like `XMLHttpRequest` or the `fetch()` API to send and receive data in the background. In modern web applications, the `fetch()` API is more commonly used to implement AJAX."
  },
  {
    "slug": "explain-event-delegation",
    "title": "Explain event delegation in JavaScript",
    "description": "Event delegation is a technique in JavaScript where a single event listener is attached to a parent element instead of attaching event listeners to multiple child elements. When an event occurs on a child element, the event bubbles up the DOM tree, and the parent element's event listener handles the event based on the target element."
  },
  {
    "slug": "explain-function-prototype-bind",
    "title": "Explain `Function.prototype.bind` in JavaScript",
    "description": "`Function.prototype.bind` is a method in JavaScript that allows you to create a new function with a specific `this` value and optional initial arguments. It's primary purpose is to:"
  },
  {
    "slug": "explain-hoisting",
    "title": "Explain the concept of \"hoisting\" in JavaScript",
    "description": "The following behavior summarizes the result of accessing the variables before they are declared."
  },
  {
    "slug": "explain-how-jsonp-works-and-how-its-not-really-ajax",
    "title": "Explain how JSONP works (and how it's not really Ajax)",
    "description": "JSONP (JSON with Padding) is a technique used to overcome the same-origin policy in web browsers, allowing you to request data from a server in a different domain. It works by dynamically creating a `<script>` tag and setting its `src` attribute to the URL of the data source. The server responds with a script that calls a predefined callback function with the data as its argument. Unlike Ajax, JSONP does not use the XMLHttpRequest object and is limited to GET requests."
  },
  {
    "slug": "explain-how-prototypal-inheritance-works",
    "title": "Explain how prototypal inheritance works in JavaScript",
    "description": "Prototypical inheritance in JavaScript is a way for objects to inherit properties and methods from other objects. Every JavaScript object has a special hidden property called `[[Prototype]]` (commonly accessed via `__proto__` or using `Object.getPrototypeOf()`) that is a reference to another object, which is called the object's \"prototype\"."
  },
  {
    "slug": "explain-how-this-works-in-javascript",
    "title": "Explain how `this` works in JavaScript",
    "description": "There's no simple explanation for `this`; it is one of the most confusing concepts in JavaScript because it's behavior differs from many other programming languages. The one-liner explanation of the `this` keyword is that it is a dynamic reference to the context in which a function is executed."
  },
  {
    "slug": "explain-the-concept-of-a-callback-function-in-asynchronous-operations",
    "title": "Explain the concept of a callback function in asynchronous operations",
    "description": "A callback function is a function passed as an argument to another function, which is then invoked inside the outer function to complete some kind of routine or action. In asynchronous operations, callbacks are used to handle tasks that take time to complete, such as network requests or file I/O, without blocking the execution of the rest of the code. For example:"
  },
  {
    "slug": "explain-the-concept-of-a-microtask-queue",
    "title": "Explain the concept of a microtask queue",
    "description": "The microtask queue is a queue of tasks that need to be executed after the currently executing script and before any other task. Microtasks are typically used for tasks that need to be executed immediately after the current operation, such as promise callbacks. The microtask queue is processed before the macrotask queue, ensuring that microtasks are executed as soon as possible."
  },
  {
    "slug": "explain-the-concept-of-caching-and-how-it-can-be-used-to-improve-performance",
    "title": "Explain the concept of caching and how it can be used to improve performance",
    "description": "Caching is a technique used to store copies of files or data in a temporary storage location to reduce the time it takes to access them. It improves performance by reducing the need to fetch data from the original source repeatedly. In front end development, caching can be implemented using browser cache, service workers, and HTTP headers like `Cache-Control`."
  },
  {
    "slug": "explain-the-concept-of-code-coverage-and-how-it-can-be-used-to-assess-test-quality",
    "title": "Explain the concept of code coverage and how it can be used to assess test quality",
    "description": "Code coverage is a metric that measures the percentage of code that is executed when the test suite runs. It helps in assessing the quality of tests by identifying untested parts of the codebase. Higher code coverage generally indicates more thorough testing, but it doesn't guarantee the absence of bugs. Tools like Istanbul or Jest can be used to measure code coverage."
  },
  {
    "slug": "explain-the-concept-of-content-security-policy-csp-and-how-it-enhances-security",
    "title": "Explain the concept of Content Security Policy (CSP) and how it enhances security",
    "description": "Content Security Policy (CSP) is a security feature that helps prevent various types of attacks, such as Cross-Site Scripting (XSS) and data injection attacks, by specifying which content sources are trusted. It works by allowing developers to define a whitelist of trusted sources for content like scripts, styles, and images. This is done through HTTP headers or meta tags. For example, you can use the `Content-Security-Policy` header to specify that only scripts from your own domain should be executed:"
  },
  {
    "slug": "explain-the-concept-of-cross-site-request-forgery-csrf-and-its-mitigation-techniques",
    "title": "Explain the concept of Cross-Site Request Forgery (CSRF) and its mitigation techniques",
    "description": "Cross-Site Request Forgery (CSRF) is an attack where a malicious website tricks a user's browser into making an unwanted request to another site where the user is authenticated. This can lead to unauthorized actions being performed on behalf of the user. Mitigation techniques include using anti-CSRF tokens, SameSite cookies, and ensuring proper CORS configurations."
  },
  {
    "slug": "explain-the-concept-of-debouncing-and-throttling",
    "title": "Explain the concept of debouncing and throttling",
    "description": "Debouncing and throttling are techniques used to control the rate at which a function is executed. Debouncing ensures that a function is only called after a specified delay has passed since the last time it was invoked. Throttling ensures that a function is called at most once in a specified time interval."
  },
  {
    "slug": "explain-the-concept-of-destructuring-assignment-for-objects-and-arrays",
    "title": "Explain the concept of destructuring assignment for objects and arrays",
    "description": "Destructuring assignment is a syntax in JavaScript that allows you to unpack values from arrays or properties from objects into distinct variables. For arrays, you use square brackets, and for objects, you use curly braces. For example:"
  },
  {
    "slug": "explain-the-concept-of-error-propagation-in-javascript",
    "title": "Explain the concept of error propagation in JavaScript",
    "description": "Error propagation in JavaScript refers to how errors are passed through the call stack. When an error occurs in a function, it can be caught and handled using `try...catch` blocks. If not caught, the error propagates up the call stack until it is either caught or causes the program to terminate. For example:"
  },
  {
    "slug": "explain-the-concept-of-hoisting-with-regards-to-functions",
    "title": "Explain the concept of hoisting with regards to functions",
    "description": "Hoisting in JavaScript is a behavior where function declarations are moved to the top of their containing scope during the compile phase. This means you can call a function before it is defined in the code. However, this does not apply to function expressions or arrow functions, which are not hoisted in the same way."
  },
  {
    "slug": "explain-the-concept-of-inheritance-in-es2015-classes",
    "title": "Explain the concept of inheritance in ES2015 classes",
    "description": "Inheritance in ES2015 classes allows one class to extend another, enabling the child class to inherit properties and methods from the parent class. This is done using the `extends` keyword. The `super` keyword is used to call the constructor and methods of the parent class. Here's a quick example:"
  },
  {
    "slug": "explain-the-concept-of-input-validation-and-its-importance-in-security",
    "title": "Explain the concept of input validation and its importance in security",
    "description": "Input validation is the process of ensuring that user input is correct, safe, and meets the application's requirements. It is crucial for security because it helps prevent attacks like SQL injection, cross-site scripting (XSS), and other forms of data manipulation. By validating input, you ensure that only properly formatted data enters your system, reducing the risk of malicious data causing harm."
  },
  {
    "slug": "explain-the-concept-of-lazy-loading-and-how-it-can-improve-performance",
    "title": "Explain the concept of lazy loading and how it can improve performance",
    "description": "Lazy loading is a design pattern that delays the loading of resources until they are actually needed. This can significantly improve performance by reducing initial load times and conserving bandwidth. For example, images on a webpage can be lazy-loaded so that they only load when they come into the viewport. This can be achieved using the `loading=\"lazy\"` attribute in HTML or by using JavaScript libraries."
  },
  {
    "slug": "explain-the-concept-of-lexical-scoping",
    "title": "Explain the concept of lexical scoping",
    "description": "Lexical scoping means that the scope of a variable is determined by its location within the source code, and nested functions have access to variables declared in their outer scope. For example:"
  },
  {
    "slug": "explain-the-concept-of-partial-application",
    "title": "Explain the concept of partial application",
    "description": "Partial application is a technique in functional programming where a function is applied to some of its arguments, producing a new function that takes the remaining arguments. This allows you to create more specific functions from general ones. For example, if you have a function `add(a, b)`, you can partially apply it to create a new function `add5` that always adds 5 to its argument."
  },
  {
    "slug": "explain-the-concept-of-scope-in-javascript",
    "title": "Explain the concept of scope in JavaScript",
    "description": "In JavaScript, scope determines the accessibility of variables and functions at different parts of the code. There are three main types of scope: global scope, function scope, and block scope. Global scope means the variable is accessible everywhere in the code. Function scope means the variable is accessible only within the function it is declared. Block scope, introduced with ES6, means the variable is accessible only within the block (e.g., within curly braces `{}`) it is declared."
  },
  {
    "slug": "explain-the-concept-of-tagged-templates",
    "title": "Explain the concept of tagged templates",
    "description": "Tagged templates in JavaScript allow you to parse template literals with a function. The function receives the literal strings and the values as arguments, enabling custom processing of the template. For example:"
  },
  {
    "slug": "explain-the-concept-of-test-driven-development-tdd",
    "title": "Explain the concept of test-driven development (TDD)",
    "description": "Test-driven development (TDD) is a software development approach where you write tests before writing the actual code. The process involves writing a failing test, writing the minimum code to pass the test, and then refactoring the code while keeping the tests passing. This ensures that the code is always tested and helps in maintaining high code quality."
  },
  {
    "slug": "explain-the-concept-of-the-prototype-pattern",
    "title": "Explain the concept of the Prototype pattern",
    "description": "The Prototype pattern is a creational design pattern used to create new objects by copying an existing object, known as the prototype. This pattern is useful when the cost of creating a new object is more expensive than cloning an existing one. In JavaScript, this can be achieved using the `Object.create` method or by using the `prototype` property of a constructor function."
  },
  {
    "slug": "explain-the-concept-of-the-singleton-pattern",
    "title": "Explain the concept of the Singleton pattern",
    "description": "The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance. This is useful when exactly one object is needed to coordinate actions across the system. In JavaScript, this can be implemented using closures or ES6 classes."
  },
  {
    "slug": "explain-the-concept-of-the-spread-operator-and-its-uses",
    "title": "Explain the concept of the spread operator and its uses",
    "description": "The spread operator (`...`) in JavaScript allows you to expand elements of an iterable (like an array or object) into individual elements. It is commonly used for copying arrays or objects, merging arrays or objects, and passing elements of an array as arguments to a function."
  },
  {
    "slug": "explain-the-concept-of-the-strategy-pattern",
    "title": "Explain the concept of the Strategy pattern",
    "description": "The Strategy pattern is a behavioral design pattern that allows you to define a family of algorithms, encapsulate each one as a separate class, and make them interchangeable. This pattern lets the algorithm vary independently from the clients that use it. For example, if you have different sorting algorithms, you can define each one as a strategy and switch between them without changing the client code."
  },
  {
    "slug": "explain-the-concept-of-the-web-socket-api",
    "title": "Explain the concept of the Web Socket API",
    "description": "The WebSocket API provides a way to open a persistent connection between a client and a server, allowing for real-time, two-way communication. Unlike HTTP, which is request-response based, WebSocket enables full-duplex communication, meaning both the client and server can send and receive messages independently. This is particularly useful for applications like chat apps, live updates, and online gaming."
  },
  {
    "slug": "explain-the-concept-of-this-binding-in-event-handlers",
    "title": "Explain the concept of `this` binding in event handlers",
    "description": "In JavaScript, the `this` keyword refers to the object that is currently executing the code. In event handlers, `this` typically refers to the element that triggered the event. However, the value of `this` can change depending on how the event handler is defined and called. To ensure `this` refers to the desired object, you can use methods like `bind()`, arrow functions, or assign the context explicitly."
  },
  {
    "slug": "explain-the-concept-of-tree-shaking-in-module-bundling",
    "title": "Explain the concept of tree shaking in module bundling",
    "description": "Tree shaking is a technique used in module bundling to eliminate dead code, which is code that is never used or executed. This helps to reduce the final bundle size and improve application performance. It works by analyzing the dependency graph of the code and removing any unused exports. Tools like Webpack and Rollup support tree shaking when using ES6 module syntax (`import` and `export`)."
  },
  {
    "slug": "explain-the-difference-between-classical-inheritance-and-prototypal-inheritance",
    "title": "Explain the difference between classical inheritance and prototypal inheritance",
    "description": "Classical inheritance is a model where classes inherit from other classes, typically seen in languages like Java and C++. Prototypal inheritance, used in JavaScript, involves objects inheriting directly from other objects. In classical inheritance, you define a class and create instances from it. In prototypal inheritance, you create an object and use it as a prototype for other objects."
  },
  {
    "slug": "explain-the-difference-between-documentqueryselector-and-documentgetelementbyid",
    "title": "Explain the difference between `document.querySelector()` and `document.getElementById()`",
    "description": "`document.querySelector()` and `document.getElementById()` are both methods used to select elements from the DOM, but they have key differences. `document.querySelector()` can select any element using a CSS selector and returns the first match, while `document.getElementById()` selects an element by its ID and returns the element with that specific ID."
  },
  {
    "slug": "explain-the-difference-between-dot-notation-and-bracket-notation-for-accessing-object-properties",
    "title": "Explain the difference between dot notation and bracket notation for accessing object properties",
    "description": "Dot notation and bracket notation are two ways to access properties of an object in JavaScript. Dot notation is more concise and readable but can only be used with valid JavaScript identifiers. Bracket notation is more flexible and can be used with property names that are not valid identifiers, such as those containing spaces or special characters."
  },
  {
    "slug": "explain-the-difference-between-global-scope-function-scope-and-block-scope",
    "title": "Explain the difference between global scope, function scope, and block scope",
    "description": "Global scope means variables are accessible from anywhere in the code. Function scope means variables are accessible only within the function they are declared in. Block scope means variables are accessible only within the block (e.g., within `{}`) they are declared in."
  },
  {
    "slug": "explain-the-difference-between-mutable-and-immutable-objects",
    "title": "Explain the difference between mutable and immutable objects in JavaScript",
    "description": "**Mutable objects** allow for modification of properties and values after creation, which is the default behavior for most objects."
  },
  {
    "slug": "explain-the-difference-between-shallow-copy-and-deep-copy",
    "title": "Explain the difference between shallow copy and deep copy",
    "description": "A shallow copy duplicates the top-level properties of an object, but nested objects are still referenced. A deep copy duplicates all levels of an object, creating entirely new instances of nested objects. For example, using `Object.assign()` creates a shallow copy, while using libraries like `Lodash` or `structuredClone()` in modern JavaScript can create deep copies."
  },
  {
    "slug": "explain-the-difference-between-synchronous-and-asynchronous-functions",
    "title": "Explain the difference between synchronous and asynchronous functions in JavaScript",
    "description": "Synchronous functions are blocking while asynchronous functions are not. In synchronous functions, statements complete before the next statement is run. As a result, programs containing only synchronous code are evaluated exactly in order of the statements. The execution of the program is paused if one of the statements take a very long time."
  },
  {
    "slug": "explain-the-difference-between-unit-testing-integration-testing-and-end-to-end-testing",
    "title": "Explain the difference between unit testing, integration testing, and end-to-end testing",
    "description": "Unit testing focuses on testing individual components or functions in isolation to ensure they work as expected. Integration testing checks how different modules or services work together. End-to-end testing simulates real user scenarios to verify the entire application flow from start to finish."
  },
  {
    "slug": "explain-the-difference-in-hoisting-between-var-let-and-const",
    "title": "Explain the difference in hoisting between `var`, `let`, and `const`",
    "description": "`var` declarations are hoisted to the top of their scope and initialized with `undefined`, allowing them to be used before their declaration. `let` and `const` declarations are also hoisted but are not initialized, resulting in a `ReferenceError` if accessed before their declaration. `const` additionally requires an initial value at the time of declaration."
  },
  {
    "slug": "explain-the-differences-between-commonjs-modules-and-es-modules",
    "title": "Explain the differences between CommonJS modules and ES modules in JavaScript",
    "description": "In JavaScript, modules are reusable pieces of code that encapsulate functionality, making it easier to manage, maintain, and structure your applications. Modules allow you to break down your code into smaller, manageable parts, each with its own scope."
  },
  {
    "slug": "explain-the-differences-on-the-usage-of-foo-between-function-foo-and-var-foo-function",
    "title": "Explain the differences on the usage of `foo` between `function foo() {}` and `var foo = function() {}` in JavaScript",
    "description": "`function foo() {}` a function declaration while the `var foo = function() {}` is a function expression. The key difference is that function declarations have its body hoisted but the bodies of function expressions are not (they have the same hoisting behavior as `var`-declared variables)."
  },
  {
    "slug": "explain-the-different-states-of-a-promise",
    "title": "Explain the different states of a Promise",
    "description": "A `Promise` in JavaScript can be in one of three states: `pending`, `fulfilled`, or `rejected`. When a `Promise` is created, it starts in the `pending` state. If the operation completes successfully, the `Promise` transitions to the `fulfilled` state, and if it fails, it transitions to the `rejected` state. Here's a quick example:"
  },
  {
    "slug": "explain-the-different-ways-the-this-keyword-can-be-bound",
    "title": "Explain the different ways the `this` keyword can be bound",
    "description": "The `this` keyword in JavaScript can be bound in several ways:"
  },
  {
    "slug": "explain-the-event-phases-in-a-browser",
    "title": "Explain the event phases in a browser",
    "description": "In a browser, events go through three phases: capturing, target, and bubbling. During the capturing phase, the event travels from the root to the target element. In the target phase, the event reaches the target element. Finally, in the bubbling phase, the event travels back up from the target element to the root. You can control event handling using `addEventListener` with the `capture` option."
  },
  {
    "slug": "explain-the-observer-pattern-and-its-use-cases",
    "title": "Explain the Observer pattern and its use cases",
    "description": "The Observer pattern is a design pattern where an object, known as the subject, maintains a list of its dependents, called observers, and notifies them of any state changes. This pattern is useful for implementing distributed event-handling systems, such as updating the user interface in response to data changes or implementing event-driven architectures."
  },
  {
    "slug": "explain-the-same-origin-policy-with-regards-to-javascript",
    "title": "Explain the same-origin policy with regards to JavaScript",
    "description": "The same-origin policy is a security measure implemented in web browsers to prevent malicious scripts on one page from accessing data on another page. It ensures that web pages can only make requests to the same origin, where the origin is defined by the combination of the protocol, domain, and port. For example, a script from `http://example.com` cannot access data from `http://anotherdomain.com`."
  },
  {
    "slug": "explain-what-a-single-page-app-is-and-how-to-make-one-seo-friendly",
    "title": "Explain what a single page app is and how to make one SEO-friendly",
    "description": "A single page application (SPA) is a web application that loads a single HTML page and dynamically updates content as the user interacts with the app. This approach provides a more fluid user experience but can be challenging for SEO because search engines may not execute JavaScript to render content. To make an SPA SEO-friendly, you can use server-side rendering (SSR) or static site generation (SSG) to ensure that search engines can index your content. Tools like Next.js for React or Nuxt.js for Vue.js can help achieve this."
  },
  {
    "slug": "explain-why-the-following-doesnt-work-as-an-iife-function-foo--what-needs-to-be-changed-to-properly-make-it-an-iife",
    "title": "Explain why the following doesn't work as an IIFE: `function foo(){}();`. What needs to be changed to properly make it an IIFE?",
    "description": "The code `function foo(){}();` doesn't work as an Immediately Invoked Function Expression (IIFE) because the JavaScript parser treats `function foo(){}` as a function declaration, not an expression. To make it an IIFE, you need to wrap the function in parentheses to turn it into a function expression: `(function foo(){})();`."
  },
  {
    "slug": "how-can-closures-be-used-to-create-private-variables",
    "title": "How can closures be used to create private variables?",
    "description": "Closures in JavaScript can be used to create private variables by defining a function within another function. The inner function has access to the outer function's variables, but those variables are not accessible from outside the outer function. This allows you to encapsulate and protect the variables from being accessed or modified directly."
  },
  {
    "slug": "how-can-you-avoid-problems-related-to-hoisting",
    "title": "How can you avoid problems related to hoisting?",
    "description": "To avoid problems related to hoisting, always declare variables at the top of their scope using `let` or `const` instead of `var`. This ensures that variables are block-scoped and not hoisted to the top of their containing function or global scope. Additionally, declare functions before they are called to avoid issues with function hoisting."
  },
  {
    "slug": "how-can-you-create-custom-error-objects",
    "title": "How can you create custom error objects?",
    "description": "To create custom error objects in JavaScript, you can extend the built-in `Error` class. This allows you to add custom properties and methods to your error objects. Here's a quick example:"
  },
  {
    "slug": "how-can-you-implement-secure-authentication-and-authorization-in-javascript-applications",
    "title": "How can you implement secure authentication and authorization in JavaScript applications?",
    "description": "To implement secure authentication and authorization in JavaScript applications, use HTTPS to encrypt data in transit, and store sensitive data like tokens securely using `localStorage` or `sessionStorage`. Implement token-based authentication using JWTs, and validate tokens on the server side. Use libraries like OAuth for third-party authentication and ensure proper role-based access control (RBAC) for authorization."
  },
  {
    "slug": "how-can-you-optimize-dom-manipulation-for-better-performance",
    "title": "How can you optimize DOM manipulation for better performance?",
    "description": "To optimize DOM manipulation for better performance, minimize direct DOM access and updates. Use techniques like batching DOM changes, using `documentFragment` for multiple elements, and leveraging virtual DOM libraries like React. Also, consider using `requestAnimationFrame` for animations and avoid layout thrashing by reading and writing DOM properties separately."
  },
  {
    "slug": "how-can-you-optimize-network-requests-for-better-performance",
    "title": "How can you optimize network requests for better performance?",
    "description": "To optimize network requests for better performance, you can minimize the number of requests, use caching, compress data, and leverage modern web technologies like HTTP/2 and service workers. For example, you can combine multiple CSS files into one to reduce the number of requests, use `Cache-Control` headers to cache static assets, and enable Gzip compression on your server to reduce the size of the data being transferred."
  },
  {
    "slug": "how-can-you-prevent-clickjacking-attacks",
    "title": "How can you prevent clickjacking attacks?",
    "description": "To prevent clickjacking attacks, you can use the `X-Frame-Options` HTTP header to control whether your site can be embedded in iframes. Set it to `DENY` to prevent all framing, or `SAMEORIGIN` to allow framing only from the same origin. Additionally, you can use the `Content-Security-Policy` (CSP) header with the `frame-ancestors` directive to specify which origins are allowed to frame your content."
  },
  {
    "slug": "how-can-you-prevent-sql-injection-vulnerabilities-in-javascript-applications",
    "title": "How can you prevent SQL injection vulnerabilities in JavaScript applications?",
    "description": "To prevent SQL injection vulnerabilities in JavaScript applications, always use parameterized queries or prepared statements instead of string concatenation to construct SQL queries. This ensures that user input is treated as data and not executable code. Additionally, use ORM libraries that handle SQL injection prevention for you, and always validate and sanitize user inputs."
  },
  {
    "slug": "how-can-you-share-code-between-files",
    "title": "How can you share code between JavaScript files?",
    "description": "To share code between JavaScript files, you can use modules. In modern JavaScript, you can use ES6 modules with `export` and `import` statements. For example, you can export a function from one file and import it into another:"
  },
  {
    "slug": "how-can-you-test-asynchronous-code-in-javascript",
    "title": "How can you test asynchronous code in JavaScript?",
    "description": "To test asynchronous code in JavaScript, you can use testing frameworks like Jest or Mocha. These frameworks provide built-in support for handling asynchronous operations. You can use `async`/`await` or return promises in your test functions. For example, in Jest, you can write:"
  },
  {
    "slug": "how-do-currying-and-partial-application-differ-from-each-other",
    "title": "How do currying and partial application differ from each other?",
    "description": "Currying transforms a function with multiple arguments into a sequence of functions, each taking a single argument. For example, a function `f(a, b, c)` becomes `f(a)(b)(c)`. Partial application, on the other hand, fixes a few arguments of a function and produces another function with a smaller number of arguments. For example, if you partially apply `f(a, b, c)` with `a`, you get a new function `f'(b, c)`."
  },
  {
    "slug": "how-do-iframe-on-a-page-communicate",
    "title": "How do `<iframe>` on a page communicate?",
    "description": "`<iframe>` elements on a page can communicate using the `postMessage` API. This allows for secure cross-origin communication between the parent page and the iframe. The `postMessage` method sends a message, and the `message` event listener receives it. Here's a simple example:"
  },
  {
    "slug": "how-do-sets-and-maps-handle-equality-checks-for-objects",
    "title": "How do `Set`s and `Map`s handle equality checks for objects?",
    "description": "`Set`s and `Map`s in JavaScript handle equality checks for objects based on reference equality, not deep equality. This means that two objects are considered equal only if they reference the same memory location. For example, if you add two different object literals with the same properties to a `Set`, they will be treated as distinct entries."
  },
  {
    "slug": "how-do-you-abort-a-web-request-using-abortcontrollers",
    "title": "How do you abort a web request using `AbortController` in JavaScript?",
    "description": "`AbortController` is used to cancel ongoing asynchronous operations like fetch requests."
  },
  {
    "slug": "how-do-you-access-the-index-of-an-element-in-an-array-during-iteration",
    "title": "How do you access the index of an element in an array during iteration?",
    "description": "To access the index of an element in an array during iteration, you can use methods like `forEach`, `map`, `for...of` with `entries`, or a traditional `for` loop. For example, using `forEach`:"
  },
  {
    "slug": "how-do-you-add-remove-and-modify-html-elements-using-javascript",
    "title": "How do you add, remove, and modify HTML elements using JavaScript?",
    "description": "To add, remove, and modify HTML elements using JavaScript, you can use methods like `createElement`, `appendChild`, `removeChild`, and properties like `innerHTML` and `textContent`. For example, to add an element, you can create it using `document.createElement` and then append it to a parent element using `appendChild`. To remove an element, you can use `removeChild` on its parent. To modify an element, you can change its `innerHTML` or `textContent`."
  },
  {
    "slug": "how-do-you-add-remove-and-update-elements-in-an-array",
    "title": "How do you add, remove, and update elements in an array?",
    "description": "To add elements to an array, you can use methods like `push`, `unshift`, or `splice`. To remove elements, you can use `pop`, `shift`, or `splice`. To update elements, you can directly access the array index and assign a new value."
  },
  {
    "slug": "how-do-you-check-if-an-object-has-a-specific-property",
    "title": "How do you check if an object has a specific property?",
    "description": "To check if an object has a specific property, you can use the `in` operator or the `hasOwnProperty` method. The `in` operator checks for both own and inherited properties, while `hasOwnProperty` checks only for own properties."
  },
  {
    "slug": "how-do-you-check-the-data-type-of-a-variable",
    "title": "How do you check the data type of a variable?",
    "description": "To check the data type of a variable in JavaScript, you can use the `typeof` operator. For example, `typeof variableName` will return a string indicating the type of the variable, such as `\"string\"`, `\"number\"`, `\"boolean\"`, `\"object\"`, `\"function\"`, `\"undefined\"`, or `\"symbol\"`. For arrays and `null`, you can use `Array.isArray(variableName)` and `variableName === null`, respectively."
  },
  {
    "slug": "how-do-you-convert-a-set-to-an-array-in-javascript",
    "title": "How do you convert a `Set` to an array in JavaScript?",
    "description": "To convert a `Set` to an array in JavaScript, you can use the `Array.from()` method or the spread operator. For example:"
  },
  {
    "slug": "how-do-you-convert-a-string-to-a-number-in-javascript",
    "title": "How do you convert a string to a number in JavaScript?",
    "description": "In JavaScript, you can convert a string to a number using several methods. The most common ones are `Number()`, `parseInt()`, `parseFloat()`, and the unary plus operator (`+`). For example, `Number(\"123\")` converts the string `\"123\"` to the number `123`, and `parseInt(\"123.45\")` converts the string `\"123.45\"` to the integer `123`."
  },
  {
    "slug": "how-do-you-create-a-constructor-function",
    "title": "How do you create a constructor function?",
    "description": "To create a constructor function in JavaScript, define a regular function with a capitalized name to indicate it's a constructor. Use the `this` keyword to set properties and methods. When creating an instance, use the `new` keyword."
  },
  {
    "slug": "how-do-you-detect-if-javascript-is-disabled-on-a-page",
    "title": "How do you detect if JavaScript is disabled on a page?",
    "description": "To detect if JavaScript is disabled on a page, you can use the `<noscript>` HTML tag. This tag allows you to display content or messages to users who have JavaScript disabled in their browsers. For example, you can include a message within the `<noscript>` tag to inform users that JavaScript is required for the full functionality of the page."
  },
  {
    "slug": "how-do-you-get-the-query-string-values-of-the-current-page-in-javascript",
    "title": "How do you get the query string values of the current page in JavaScript?",
    "description": "To get the query string values of the current page in JavaScript, you can use the `URLSearchParams` object. First, create a `URLSearchParams` instance with `window.location.search`, then use the `get` method to retrieve specific query parameters. For example:"
  },
  {
    "slug": "how-do-you-handle-errors-in-asynchronous-operations",
    "title": "How do you handle errors in asynchronous operations?",
    "description": "To handle errors in asynchronous operations, you can use `try...catch` blocks with `async/await` syntax or `.catch()` method with Promises. For example, with `async/await`, you can wrap your code in a `try...catch` block to catch any errors:"
  },
  {
    "slug": "how-do-you-handle-errors-using-trycatch-blocks",
    "title": "How do you handle errors using `try...catch` blocks?",
    "description": "To handle errors using `try...catch` blocks, you wrap the code that might throw an error inside a `try` block. If an error occurs, the control is transferred to the `catch` block where you can handle the error. Optionally, you can use a `finally` block to execute code regardless of whether an error occurred or not."
  },
  {
    "slug": "how-do-you-import-and-export-modules-in-javascript",
    "title": "How do you import and export modules in JavaScript?",
    "description": "In JavaScript, you can import and export modules using the `import` and `export` statements. To export a module, you can use `export` before a function, variable, or class, or use `export default` for a single default export. To import a module, you use the `import` statement followed by the name of the exported module and the path to the module file."
  },
  {
    "slug": "how-do-you-make-an-http-request-using-the-fetch-api",
    "title": "How do you make an HTTP request using the Fetch API?",
    "description": "To make an HTTP request using the Fetch API, you can use the `fetch` function, which returns a promise. You can handle the response using `.then()` and `.catch()` for error handling. Here's a basic example of a GET request:"
  },
  {
    "slug": "how-do-you-manipulate-css-styles-using-javascript",
    "title": "How do you manipulate CSS styles using JavaScript?",
    "description": "You can manipulate CSS styles using JavaScript by accessing the `style` property of an HTML element. For example, to change the background color of a `div` element with the id `myDiv`, you can use:"
  },
  {
    "slug": "how-do-you-organize-your-code-module-pattern-classical-inheritance",
    "title": "How do you organize your code?",
    "description": "I organize my code by following a modular approach, using a clear folder structure, and adhering to coding standards and best practices. I separate concerns by dividing code into different layers such as components, services, and utilities. I also use naming conventions and documentation to ensure code readability and maintainability."
  },
  {
    "slug": "how-do-you-prevent-the-default-behavior-of-an-event",
    "title": "How do you prevent the default behavior of an event?",
    "description": "To prevent the default behavior of an event in JavaScript, you can use the `preventDefault` method on the event object. For example, if you want to prevent a form from submitting, you can do the following:"
  },
  {
    "slug": "how-do-you-redirect-to-a-new-page-in-javascript",
    "title": "How do you redirect to a new page in JavaScript?",
    "description": "To redirect to a new page in JavaScript, you can use the `window.location` object. The most common methods are `window.location.href` and `window.location.replace()`. For example:"
  },
  {
    "slug": "how-do-you-reliably-determine-whether-an-object-is-empty",
    "title": "How do you reliably determine whether an object is empty?",
    "description": "To reliably determine whether an object is empty, you can use `Object.keys()` to check if the object has any enumerable properties. If the length of the array returned by `Object.keys()` is zero, the object is empty."
  },
  {
    "slug": "how-do-you-use-windowhistory-api",
    "title": "How do you use `window.history` API?",
    "description": "The `window.history` API allows you to manipulate the browser's session history. You can use `history.pushState()` to add a new entry to the history stack, `history.replaceState()` to modify the current entry, and `history.back()`, `history.forward()`, and `history.go()` to navigate through the history. For example, `history.pushState({page: 1}, \"title 1\", \"?page=1\")` adds a new entry to the history."
  },
  {
    "slug": "how-do-you-validate-form-elements-using-the-constraint-validation-api",
    "title": "How do you validate form elements using the Constraint Validation API?",
    "description": "The Constraint Validation API provides a way to validate form elements in HTML. You can use properties like `validity`, `validationMessage`, and methods like `checkValidity()` and `setCustomValidity()`. For example, to check if an input is valid, you can use:"
  },
  {
    "slug": "how-do-you-write-unit-tests-for-javascript-code",
    "title": "How do you write unit tests for JavaScript code?",
    "description": "To write unit tests for JavaScript code, you typically use a testing framework like Jest or Mocha. First, you set up your testing environment by installing the necessary libraries. Then, you write test cases using functions like `describe`, `it`, or `test` to define your tests. Each test case should focus on a small, isolated piece of functionality. You use assertions to check if the output of your code matches the expected result."
  },
  {
    "slug": "how-does-hoisting-affect-function-declarations-and-expressions",
    "title": "How does hoisting affect function declarations and expressions?",
    "description": "Hoisting in JavaScript means that function declarations are moved to the top of their containing scope during the compile phase, making them available throughout the entire scope. This allows you to call a function before it is defined in the code. However, function expressions are not hoisted in the same way. If you try to call a function expression before it is defined, you will get an error because the variable holding the function is hoisted but not its assignment."
  },
  {
    "slug": "how-does-javascript-garbage-collection-work",
    "title": "How does JavaScript garbage collection work?",
    "description": "Garbage collection in JavaScript is an automatic memory management mechanism that reclaims memory occupied by objects and variables that are no longer in use by the program. The two most common algorithms are mark-and-sweep and generational garbage collection."
  },
  {
    "slug": "how-is-promiseall-different-from-promiseallsettled",
    "title": "How is `Promise.all()` different from `Promise.allSettled()`?",
    "description": "`Promise.all()` and `Promise.allSettled()` are both methods for handling multiple promises in JavaScript, but they behave differently. `Promise.all()` waits for all promises to resolve and fails fast if any promise rejects, returning a single rejected promise. `Promise.allSettled()`, on the other hand, waits for all promises to settle (either resolve or reject) and returns an array of objects describing the outcome of each promise."
  },
  {
    "slug": "provide-some-examples-of-how-currying-and-partial-application-can-be-used",
    "title": "Provide some examples of how currying and partial application can be used",
    "description": "Currying transforms a function with multiple arguments into a sequence of functions, each taking a single argument. Partial application fixes a few arguments of a function, producing another function with a smaller number of arguments. For example, currying a function `add(a, b)` would look like `add(a)(b)`, while partial application of `add(2, b)` would fix the first argument to 2, resulting in a function that only needs the second argument."
  },
  {
    "slug": "what-advantage-is-there-for-using-the-arrow-syntax-for-a-method-in-a-constructor",
    "title": "What advantage is there for using the JavaScript arrow syntax for a method in a constructor?",
    "description": "The main advantage of using an arrow function as a method inside a constructor is that the value of `this` gets set at the time of the function creation and can't change after that. When the constructor is used to create a new object, `this` will always refer to that object."
  },
  {
    "slug": "what-are-callback-functions-and-how-are-they-used",
    "title": "What are callback functions and how are they used?",
    "description": "A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action. They are commonly used for asynchronous operations like handling events, making API calls, or reading files. For example:"
  },
  {
    "slug": "what-are-default-parameters-and-how-are-they-used",
    "title": "What are default parameters and how are they used?",
    "description": "Default parameters in JavaScript allow you to set default values for function parameters if no value or `undefined` is passed. This helps avoid `undefined` values and makes your code more robust. You can define default parameters by assigning a value to the parameter in the function definition."
  },
  {
    "slug": "what-are-design-patterns-and-why-are-they-useful",
    "title": "What are design patterns and why are they useful?",
    "description": "Design patterns are reusable solutions to common problems in software design. They provide a template for how to solve a problem that can be used in many different situations. They are useful because they help developers avoid common pitfalls, improve code readability, and make it easier to maintain and scale applications."
  },
  {
    "slug": "what-are-event-listeners-and-how-are-they-used",
    "title": "What are event listeners and how are they used?",
    "description": "Event listeners are functions that wait for specific events to occur on elements, such as clicks or key presses. They are used to execute code in response to these events. You can add an event listener to an element using the `addEventListener` method. For example:"
  },
  {
    "slug": "what-are-iterators-and-generators-and-what-are-they-used-for",
    "title": "What are iterators and generators in JavaScript and what are they used for?",
    "description": "In JavaScript, iterators and generators are powerful tools for managing sequences of data and controlling the flow of execution in a more flexible way."
  },
  {
    "slug": "what-are-javascript-object-getters-and-setters-for",
    "title": "What are JavaScript object getters and setters for?",
    "description": "JavaScript object getters and setters are used to control access to an object's properties. They provide a way to encapsulate the implementation details of a property and define custom behavior when getting or setting its value."
  },
  {
    "slug": "what-are-javascript-object-property-flags-and-descriptors",
    "title": "What are JavaScript object property flags and descriptors?",
    "description": "In JavaScript, property flags and descriptors manage the behavior and attributes of object properties."
  },
  {
    "slug": "what-are-javascript-polyfills-for",
    "title": "What are JavaScript polyfills for?",
    "description": "Polyfills in JavaScript are pieces of code that provide modern functionality to older browsers that lack native support for those features. They bridge the gap between the JavaScript language features and APIs available in modern browsers and the limited capabilities of older browser versions."
  },
  {
    "slug": "what-are-mocks-and-stubs-and-how-are-they-used-in-testing",
    "title": "What are mocks and stubs and how are they used in testing?",
    "description": "Mocks and stubs are tools used in testing to simulate the behavior of real objects. Stubs provide predefined responses to function calls, while mocks are more complex and can verify interactions, such as whether a function was called and with what arguments. Stubs are used to isolate the code being tested from external dependencies, and mocks are used to ensure that the code interacts correctly with those dependencies."
  },
  {
    "slug": "what-are-modules-and-why-are-they-useful",
    "title": "What are modules and why are they useful?",
    "description": "Modules are reusable pieces of code that can be imported and exported between different files in a project. They help in organizing code, making it more maintainable and scalable. By using modules, you can avoid global namespace pollution and manage dependencies more effectively. In JavaScript, you can use `import` and `export` statements to work with modules."
  },
  {
    "slug": "what-are-progressive-web-applications-pwas",
    "title": "What are Progressive Web Applications (PWAs)?",
    "description": "Progressive Web Applications (PWAs) are web applications that use modern web capabilities to deliver an app-like experience to users. They are reliable, fast, and engaging. PWAs can work offline, send push notifications, and be installed on a user's home screen. They leverage technologies like service workers, web app manifests, and HTTPS to provide these features."
  },
  {
    "slug": "what-are-promises-and-how-do-they-work",
    "title": "What are Promises and how do they work?",
    "description": "Promises in JavaScript are objects that represent the eventual completion (or failure) of an asynchronous operation and its resulting value. They have three states: `pending`, `fulfilled`, and `rejected`. You can handle the results of a promise using the `.then()` method for success and the `.catch()` method for errors."
  },
  {
    "slug": "what-are-proxies-in-javascript-used-for",
    "title": "What are proxies in JavaScript used for?",
    "description": "In JavaScript, a proxy is an object that acts as an intermediary between an object and the code. Proxies are used to intercept and customize the fundamental operations of JavaScript objects, such as property access, assignment, function invocation, and more."
  },
  {
    "slug": "what-are-rest-parameters-and-how-are-they-used",
    "title": "What are rest parameters and how are they used?",
    "description": "Rest parameters in JavaScript allow a function to accept an indefinite number of arguments as an array. They are denoted by three dots (`...`) followed by the name of the array. This feature is useful for functions that need to handle multiple arguments without knowing the exact number in advance."
  },
  {
    "slug": "what-are-server-sent-events",
    "title": "What are server-sent events?",
    "description": "[Server-sent events (SSE)](https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface) is a standard that allows a web page to receive automatic updates from a server via an HTTP connection. Server-sent events are used with `EventSource` instances that opens a connection with a server and allows client to receive events from the server. Connections created by server-sent events are persistent (similar to the `WebSocket`s), however there are a few differences:"
  },
  {
    "slug": "what-are-sets-and-maps-and-how-are-they-used",
    "title": "What are `Set`s and `Map`s and how are they used?",
    "description": "`Set`s and `Map`s are built-in JavaScript objects that help manage collections of data. A `Set` is a collection of unique values, while a `Map` is a collection of key-value pairs where keys can be of any type. `Set`s are useful for storing unique items, and `Map`s are useful for associating values with keys."
  },
  {
    "slug": "what-are-some-best-practices-for-handling-sensitive-data-in-javascript",
    "title": "What are some best practices for handling sensitive data in JavaScript?",
    "description": "Handling sensitive data in JavaScript requires careful attention to security practices. Avoid storing sensitive data in client-side storage like localStorage or sessionStorage. Use HTTPS to encrypt data in transit. Implement proper authentication and authorization mechanisms. Sanitize and validate all inputs to prevent injection attacks. Consider using environment variables for sensitive data in server-side code."
  },
  {
    "slug": "what-are-some-best-practices-for-writing-maintainable-and-effective-tests",
    "title": "What are some best practices for writing maintainable and effective tests in JavaScript?",
    "description": "To write maintainable and effective tests, ensure they are clear, concise, and focused on a single behavior. Use descriptive names for test cases and avoid hardcoding values. Mock external dependencies and keep tests isolated. Regularly review and refactor tests to keep them up-to-date with the codebase."
  },
  {
    "slug": "what-are-some-common-performance-bottlenecks-in-javascript-applications",
    "title": "What are some common performance bottlenecks in JavaScript applications?",
    "description": "Common performance bottlenecks in JavaScript applications include inefficient DOM manipulation, excessive use of global variables, blocking the main thread with heavy computations, memory leaks, and improper use of asynchronous operations. To mitigate these issues, you can use techniques like debouncing and throttling, optimizing DOM updates, and leveraging web workers for heavy computations."
  },
  {
    "slug": "what-are-some-common-security-headers-and-their-purpose",
    "title": "What are some common security headers and their purpose?",
    "description": "Security headers are HTTP response headers that help protect web applications from various attacks. Some common security headers include:"
  },
  {
    "slug": "what-are-some-of-the-advantages-disadvantages-of-writing-javascript-code-in-a-language-that-compiles-to-javascript",
    "title": "What are some of the advantages/disadvantages of writing JavaScript code in a language that compiles to JavaScript?",
    "description": "Using languages that compile to JavaScript, like TypeScript or CoffeeScript, can offer several advantages such as improved syntax, type safety, and better tooling. However, they also come with disadvantages like added build steps, potential performance overhead, and the need to learn new syntax."
  },
  {
    "slug": "what-are-some-popular-javascript-testing-frameworks",
    "title": "What are some popular JavaScript testing frameworks?",
    "description": "Some popular JavaScript testing frameworks include Jest, Mocha, Jasmine, and Cypress. Jest is known for its simplicity and integration with React. Mocha is highly flexible and often used with other libraries like Chai for assertions. Jasmine is a behavior-driven development framework that requires no additional libraries. Cypress is an end-to-end testing framework that provides a great developer experience."
  },
  {
    "slug": "what-are-some-techniques-for-reducing-reflows-and-repaints",
    "title": "What are some techniques for reducing reflows and repaints?",
    "description": "To reduce reflows and repaints, you can minimize DOM manipulations, batch DOM changes, use CSS classes for style changes, avoid complex CSS selectors, and use `requestAnimationFrame` for animations. Additionally, consider using `will-change` for elements that will change frequently and avoid layout thrashing by reading and writing to the DOM separately."
  },
  {
    "slug": "what-are-some-tools-and-techniques-for-identifying-security-vulnerabilities-in-javascript-code",
    "title": "What are some tools and techniques for identifying security vulnerabilities in JavaScript code?",
    "description": "To identify security vulnerabilities in JavaScript code, you can use static code analysis tools like ESLint with security plugins, dynamic analysis tools like OWASP ZAP, and dependency checkers like npm audit. Additionally, manual code reviews and adhering to secure coding practices are essential techniques."
  },
  {
    "slug": "what-are-some-tools-that-can-be-used-for-javascript-testing",
    "title": "What are some tools that can be used for JavaScript testing?",
    "description": "For JavaScript testing, you can use tools like Jest, Mocha, Jasmine, and Cypress. Jest is popular for its ease of use and built-in features. Mocha is flexible and can be paired with other libraries. Jasmine is known for its simplicity and behavior-driven development (BDD) style. Cypress is great for end-to-end testing with a focus on real browser interactions."
  },
  {
    "slug": "what-are-some-tools-that-can-be-used-to-measure-and-analyze-javascript-performance",
    "title": "What are some tools that can be used to measure and analyze JavaScript performance?",
    "description": "To measure and analyze JavaScript performance, you can use tools like Chrome DevTools, Lighthouse, WebPageTest, and JSPerf. Chrome DevTools provides a Performance panel for profiling, Lighthouse offers audits for performance metrics, WebPageTest allows for detailed performance testing, and JSPerf helps in comparing the performance of different JavaScript snippets."
  },
  {
    "slug": "what-are-symbols-used-for",
    "title": "What are `Symbol`s used for in JavaScript?",
    "description": "`Symbol`s in JavaScript are a new primitive data type introduced in ES6 (ECMAScript 2015). They are unique and immutable identifiers that is primarily for object property keys to avoid name collisions. These values can be created using `Symbol(...)` function, and each `Symbol` value is guaranteed to be unique, even if they have the same key/description. `Symbol` properties are not enumerable in `for...in` loops or `Object.keys()`, making them suitable for creating private/internal object state."
  },
  {
    "slug": "what-are-template-literals-and-how-are-they-used",
    "title": "What are template literals and how are they used?",
    "description": "Template literals are a feature in JavaScript that allow for easier string interpolation and multi-line strings. They are enclosed by backticks (`` ` ``) instead of single or double quotes. You can embed expressions within template literals using `${expression}` syntax."
  },
  {
    "slug": "what-are-the-advantages-and-disadvantages-of-using-ajax",
    "title": "What are the advantages and disadvantages of using AJAX?",
    "description": "AJAX (Asynchronous JavaScript and XML) is a technique in JavaScript that allows web pages to send and retrieve data asynchronously from servers without refreshing or reloading the entire page."
  },
  {
    "slug": "what-are-the-advantages-of-using-the-spread-operator-with-arrays-and-objects",
    "title": "What are the advantages of using the spread operator with arrays and objects?",
    "description": "The spread operator (`...`) in JavaScript allows you to easily copy arrays and objects, merge them, and add new elements or properties. It simplifies syntax and improves readability. For arrays, it can be used to concatenate or clone arrays. For objects, it can be used to merge objects or add new properties."
  },
  {
    "slug": "what-are-the-benefits-of-using-a-module-bundler",
    "title": "What are the benefits of using a module bundler?",
    "description": "Using a module bundler like Webpack, Rollup, or Parcel helps manage dependencies, optimize performance, and improve the development workflow. It combines multiple JavaScript files into a single file or a few files, which reduces the number of HTTP requests and can include features like code splitting, tree shaking, and hot module replacement."
  },
  {
    "slug": "what-are-the-benefits-of-using-currying-and-partial-application",
    "title": "What are the benefits of using currying and partial application?",
    "description": "Currying transforms a function with multiple arguments into a sequence of functions, each taking a single argument. This allows for more flexible and reusable code. Partial application, on the other hand, allows you to fix a few arguments of a function and generate a new function. Both techniques help in creating more modular and maintainable code."
  },
  {
    "slug": "what-are-the-benefits-of-using-spread-syntax-and-how-is-it-different-from-rest-syntax",
    "title": "What are the benefits of using spread syntax in JavaScript and how is it different from rest syntax?",
    "description": "**Spread syntax** (`...`) allows an iterable (like an array or string) to be expanded into individual elements. This is often used as a convenient and modern way to create new arrays or objects by combining existing ones."
  },
  {
    "slug": "what-are-the-common-pitfalls-of-using-the-this-keyword",
    "title": "What are the common pitfalls of using the `this` keyword?",
    "description": "The `this` keyword in JavaScript can be tricky because its value depends on how a function is called. Common pitfalls include losing the context of `this` when passing methods as callbacks, using `this` in nested functions, and misunderstanding `this` in arrow functions. To avoid these issues, you can use `.bind()`, arrow functions, or store the context in a variable."
  },
  {
    "slug": "what-are-the-differences-between-es6-class-and-es5-function-constructors",
    "title": "What are the differences between JavaScript ES2015 classes and ES5 function constructors?",
    "description": "ES2015 introduces a new way of creating classes, which provides a more intuitive and concise way to define and work with objects and inheritance compared to the ES5 function constructor syntax. Here's an example of each:"
  },
  {
    "slug": "what-are-the-differences-between-map-set-and-weakmap-weakset",
    "title": "What are the differences between `Map`/`Set` and `WeakMap`/`WeakSet` in JavaScript?",
    "description": "The primary difference between `Map`/`Set` and `WeakMap`/`WeakSet` in JavaScript lies in how they handle keys. Here's a breakdown:"
  },
  {
    "slug": "what-are-the-differences-between-variables-created-using-let-var-or-const",
    "title": "What are the differences between JavaScript variables created using `let`, `var` or `const`?",
    "description": "In JavaScript, `let`, `var`, and `const` are all keywords used to declare variables, but they differ significantly in terms of scope, initialization rules, whether they can be redeclared or reassigned and the behavior when they are accessed before declaration:"
  },
  {
    "slug": "what-are-the-differences-between-xmlhttprequest-and-fetch",
    "title": "What are the differences between `XMLHttpRequest` and `fetch()` in JavaScript and browsers?",
    "description": "`XMLHttpRequest` (XHR) and `fetch()` API are both used for asynchronous HTTP requests in JavaScript (AJAX). `fetch()` offers a cleaner syntax, promise-based approach, and more modern feature set compared to XHR. However, there are some differences:"
  },
  {
    "slug": "what-are-the-different-methods-for-iterating-over-an-array",
    "title": "What are the different methods for iterating over an array?",
    "description": "There are several methods to iterate over an array in JavaScript. The most common ones include `for` loops, `forEach`, `map`, `filter`, `reduce`, and `for...of`. Each method has its own use case. For example, `for` loops are versatile and can be used for any kind of iteration, while `forEach` is specifically for executing a function on each array element. `map` is used for transforming arrays, `filter` for filtering elements, `reduce` for accumulating values, and `for...of` for iterating over iterable objects."
  },
  {
    "slug": "what-are-the-different-types-of-errors-in-javascript",
    "title": "What are the different types of errors in JavaScript?",
    "description": "In JavaScript, there are three main types of errors: syntax errors, runtime errors, and logical errors. Syntax errors occur when the code violates the language's grammar rules, such as missing a parenthesis. Runtime errors happen during code execution, like trying to access a property of `undefined`. Logical errors are mistakes in the code's logic that lead to incorrect results but don't throw an error."
  },
  {
    "slug": "what-are-the-different-types-of-testing-in-software-development",
    "title": "What are the different types of testing in software development?",
    "description": "In software development, there are several types of testing to ensure the quality and functionality of the application. These include unit testing, integration testing, system testing, and acceptance testing. Unit testing focuses on individual components, integration testing checks the interaction between components, system testing evaluates the entire system, and acceptance testing ensures the software meets user requirements."
  },
  {
    "slug": "what-are-the-different-ways-to-copy-an-object-or-an-array",
    "title": "What are the different ways to copy an object or an array?",
    "description": "To copy an object or an array in JavaScript, you can use several methods. For shallow copies, you can use the spread operator (`...`) or `Object.assign()`. For deep copies, you can use `JSON.parse(JSON.stringify())` or libraries like Lodash's `_.cloneDeep()`."
  },
  {
    "slug": "what-are-the-different-ways-to-make-an-api-call-in-javascript",
    "title": "What are the different ways to make an API call in JavaScript?",
    "description": "In JavaScript, you can make API calls using several methods. The most common ones are `XMLHttpRequest`, `fetch`, and third-party libraries like `Axios`. `XMLHttpRequest` is the traditional way but is more verbose. `fetch` is modern and returns promises, making it easier to work with. `Axios` is a popular third-party library that simplifies API calls and provides additional features."
  },
  {
    "slug": "what-are-the-metadata-fields-of-a-module",
    "title": "What are the metadata fields of a module?",
    "description": "Metadata fields of a module typically include information such as the module's name, version, description, author, license, and dependencies. These fields are often found in a `package.json` file in JavaScript projects. For example:"
  },
  {
    "slug": "what-are-the-potential-issues-caused-by-hoisting",
    "title": "What are the potential issues caused by hoisting?",
    "description": "Hoisting can lead to unexpected behavior in JavaScript because variable and function declarations are moved to the top of their containing scope during the compilation phase. This can result in `undefined` values for variables if they are used before their declaration and can cause confusion with function declarations and expressions. For example:"
  },
  {
    "slug": "what-are-the-potential-pitfalls-of-using-closures",
    "title": "What are the potential pitfalls of using closures?",
    "description": "Closures can lead to memory leaks if not managed properly, especially when they capture variables that are no longer needed. They can also make debugging more difficult due to the complexity of the scope chain. Additionally, closures can cause performance issues if they are overused or used inappropriately, as they keep references to variables in their scope, which can prevent garbage collection."
  },
  {
    "slug": "what-are-the-pros-and-cons-of-using-promises-instead-of-callbacks",
    "title": "What are the pros and cons of using Promises instead of callbacks in JavaScript?",
    "description": "Promises offer a cleaner alternative to callbacks, helping to avoid callback hell and making asynchronous code more readable. They facilitate writing sequential and parallel asynchronous operations with ease. However, using promises may introduce slightly more complex code."
  },
  {
    "slug": "what-are-the-various-data-types-in-javascript",
    "title": "What are the various data types in JavaScript?",
    "description": "In JavaScript, data types can be categorized into `primitive` and `non-primitive` types:"
  },
  {
    "slug": "what-are-the-various-ways-to-create-objects-in-javascript",
    "title": "What are the various ways to create objects in JavaScript?",
    "description": "Creating objects in JavaScript offers several methods:"
  },
  {
    "slug": "what-are-web-workers-and-how-can-they-be-used-to-improve-performance",
    "title": "What are Web Workers and how can they be used to improve performance?",
    "description": "Web Workers are a way to run JavaScript in the background, separate from the main execution thread of a web application. This helps in performing heavy computations without blocking the user interface. You can create a Web Worker using the `Worker` constructor and communicate with it using the `postMessage` and `onmessage` methods."
  },
  {
    "slug": "what-are-workers-in-javascript-used-for",
    "title": "What are workers in JavaScript used for?",
    "description": "Workers in JavaScript are background threads that allow you to run scripts in parallel with the main execution thread, without blocking or interfering with the user interface. Their key features include:"
  },
  {
    "slug": "what-do-you-think-of-amd-vs-commonjs",
    "title": "What do you think of AMD vs CommonJS?",
    "description": "AMD (Asynchronous Module Definition) and CommonJS are two JavaScript module systems. AMD is designed for asynchronous loading of modules, making it suitable for browsers. CommonJS is designed for synchronous loading, making it more suitable for server-side environments like Node.js. AMD uses `define` and `require` for defining and loading modules, while CommonJS uses `module.exports` and `require`."
  },
  {
    "slug": "what-is-a-closure-and-how-why-would-you-use-one",
    "title": "What is a closure in JavaScript, and how/why would you use one?",
    "description": "In the book [\"You Don't Know JS\"](https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures) (YDKJS) by Kyle Simpson, a closure is defined as follows:"
  },
  {
    "slug": "what-is-asyncawait-and-how-does-it-simplify-asynchronous-code",
    "title": "What is async/await and how does it simplify asynchronous code?",
    "description": "`async/await` is a modern syntax in JavaScript that simplifies working with promises. By using the `async` keyword before a function, you can use the `await` keyword inside that function to pause execution until a promise is resolved. This makes asynchronous code look and behave more like synchronous code, making it easier to read and maintain."
  },
  {
    "slug": "what-is-cross-site-scripting-xss-and-how-can-you-prevent-it",
    "title": "What is Cross-Site Scripting (XSS) and how can you prevent it?",
    "description": "Cross-Site Scripting (XSS) is a security vulnerability that allows attackers to inject malicious scripts into web pages viewed by other users. This can lead to data theft, session hijacking, and other malicious activities. To prevent XSS, you should validate and sanitize user inputs, use Content Security Policy (CSP), and escape data before rendering it in the browser."
  },
  {
    "slug": "what-is-currying-and-how-does-it-work",
    "title": "What is currying and how does it work?",
    "description": "Currying is a technique in functional programming where a function that takes multiple arguments is transformed into a series of functions that each take a single argument. This allows for partial application of functions. For example, a function `f(a, b, c)` can be curried into `f(a)(b)(c)`. Here's a simple example in JavaScript:"
  },
  {
    "slug": "what-is-event-loop-what-is-the-difference-between-call-stack-and-task-queue",
    "title": "What is the event loop in JavaScript runtimes?",
    "description": "The event loop is concept within the browser runtime environment regarding how asynchronous operations are executed within JavaScript engines. It works as such:"
  },
  {
    "slug": "what-is-objectfreeze-for",
    "title": "What is `Object.freeze()` for?",
    "description": "`Object.freeze()` is used to make an object immutable. Once an object is frozen, you cannot add, remove, or modify its properties. This is useful for creating constants or ensuring that an object remains unchanged throughout the program."
  },
  {
    "slug": "what-is-objectpreventextensions-for",
    "title": "What is `Object.preventExtensions()` for?",
    "description": "`Object.preventExtensions()` is a method in JavaScript that prevents new properties from being added to an object. However, it does not affect the deletion or modification of existing properties. This method is useful when you want to ensure that an object remains in a certain shape and no additional properties can be added to it."
  },
  {
    "slug": "what-is-objectseal-for",
    "title": "What is `Object.seal()` for?",
    "description": "`Object.seal()` is used to prevent new properties from being added to an object and to mark all existing properties as non-configurable. This means you can still modify the values of existing properties, but you cannot delete them or add new ones."
  },
  {
    "slug": "what-is-recursion-and-how-is-it-used-in-javascript",
    "title": "What is recursion and how is it used in JavaScript?",
    "description": "Recursion is a programming technique where a function calls itself to solve a problem. In JavaScript, recursion is used to solve problems that can be broken down into smaller, similar sub-problems. A base case is essential to stop the recursive calls and prevent infinite loops. For example, calculating the factorial of a number can be done using recursion:"
  },
  {
    "slug": "what-is-the-command-pattern-and-how-is-it-used",
    "title": "What is the Command pattern and how is it used?",
    "description": "The Command pattern is a behavioral design pattern that turns a request into a stand-alone object containing all information about the request. This transformation allows for parameterization of methods with different requests, queuing of requests, and logging of the requests. It also supports undoable operations. In JavaScript, it can be implemented by creating command objects with `execute` and `undo` methods."
  },
  {
    "slug": "what-is-the-decorator-pattern-and-how-is-it-used",
    "title": "What is the Decorator pattern and how is it used?",
    "description": "The Decorator pattern is a structural design pattern that allows behavior to be added to individual objects, dynamically, without affecting the behavior of other objects from the same class. It is used to extend the functionalities of objects by wrapping them with additional behavior. In JavaScript, this can be achieved using higher-order functions or classes."
  },
  {
    "slug": "what-is-the-definition-of-a-higher-order-function",
    "title": "What is the definition of a higher-order function in JavaScript?",
    "description": "A higher-order function is any function that takes one or more functions as arguments, which it uses to operate on some data, and/or returns a function as a result."
  },
  {
    "slug": "what-is-the-difference-between-a-map-object-and-a-plain-object-in-javascript",
    "title": "What is the difference between a `Map` object and a plain object in JavaScript?",
    "description": "Both `Map` objects and plain objects in JavaScript can store key-value pairs, but they have several key differences:"
  },
  {
    "slug": "what-is-the-difference-between-a-parameter-and-an-argument",
    "title": "What is the difference between a parameter and an argument?",
    "description": "A parameter is a variable in the declaration of a function, while an argument is the actual value passed to the function when it is called. For example, in the function `function add(a, b) { return a + b; }`, `a` and `b` are parameters. When you call `add(2, 3)`, `2` and `3` are arguments."
  },
  {
    "slug": "what-is-the-difference-between-double-equal-and-triple-equal",
    "title": "What is the difference between `==` and `===` in JavaScript?",
    "description": "`==` is the abstract equality operator while `===` is the strict equality operator. The `==` operator will compare for equality after doing any necessary type conversions. The `===` operator will not do type conversion, so if two values are not the same type `===` will simply return `false`."
  },
  {
    "slug": "what-is-the-difference-between-eventpreventdefault-and-eventstoppropagation",
    "title": "What is the difference between `event.preventDefault()` and `event.stopPropagation()`?",
    "description": "`event.preventDefault()` is used to prevent the default action that belongs to the event, such as preventing a form from submitting. `event.stopPropagation()` is used to stop the event from bubbling up to parent elements, preventing any parent event handlers from being executed."
  },
  {
    "slug": "what-is-the-difference-between-innerhtml-and-textcontent",
    "title": "What is the difference between `innerHTML` and `textContent`?",
    "description": "`innerHTML` and `textContent` are both properties used to get or set the content of an HTML element, but they serve different purposes. `innerHTML` returns or sets the HTML markup contained within the element, which means it can parse and render HTML tags. On the other hand, `textContent` returns or sets the text content of the element, ignoring any HTML tags and rendering them as plain text."
  },
  {
    "slug": "what-is-the-difference-between-mouseenter-and-mouseover-event",
    "title": "What is the difference between `mouseenter` and `mouseover` event in JavaScript and browsers?",
    "description": "The main difference lies in the bubbling behavior of `mouseenter` and `mouseover` events. `mouseenter` does not bubble while `mouseover` bubbles."
  },
  {
    "slug": "what-is-the-difference-between-settimeout-setimmediate-and-processnexttick",
    "title": "What is the difference between `setTimeout()`, `setImmediate()`, and `process.nextTick()`?",
    "description": "`setTimeout()` schedules a callback to run after a minimum delay. `setImmediate()` schedules a callback to run after the current event loop completes. `process.nextTick()` schedules a callback to run before the next event loop iteration begins."
  },
  {
    "slug": "what-is-the-difference-between-the-window-object-and-the-document-object",
    "title": "What is the difference between the Window object and the Document object?",
    "description": "The `Window` object represents the browser window and provides methods to control it, such as opening new windows or accessing the browser history. The `Document` object represents the content of the web page loaded in the window and provides methods to manipulate the DOM, such as selecting elements or modifying their content."
  },
  {
    "slug": "what-is-the-dom-and-how-is-it-structured",
    "title": "What is the DOM and how is it structured?",
    "description": "The DOM, or Document Object Model, is a programming interface for web documents. It represents the page so that programs can change the document structure, style, and content. The DOM is structured as a tree of objects, where each node represents part of the document, such as elements, attributes, and text."
  },
  {
    "slug": "what-is-the-factory-pattern-and-how-is-it-used",
    "title": "What is the Factory pattern and how is it used?",
    "description": "The Factory pattern is a design pattern used to create objects without specifying the exact class of the object that will be created. It provides a way to encapsulate the instantiation logic and can be particularly useful when the creation process is complex or when the type of object to be created is determined at runtime."
  },
  {
    "slug": "what-is-the-intl-namespace-object-for",
    "title": "What is the `Intl` namespace object for?",
    "description": "The `Intl` namespace object in JavaScript is used for internationalization purposes. It provides language-sensitive string comparison, number formatting, and date and time formatting. For example, you can use `Intl.DateTimeFormat` to format dates according to a specific locale:"
  },
  {
    "slug": "what-is-the-module-pattern-and-how-does-it-help-with-encapsulation",
    "title": "What is the Module pattern and how does it help with encapsulation?",
    "description": "The Module pattern in JavaScript is a design pattern used to create self-contained modules of code. It helps with encapsulation by allowing you to define private and public members within a module. Private members are not accessible from outside the module, while public members are exposed through a returned object. This pattern helps in organizing code, avoiding global namespace pollution, and maintaining a clean separation of concerns."
  },
  {
    "slug": "what-is-the-prototype-chain-and-how-does-it-work",
    "title": "What is the prototype chain and how does it work?",
    "description": "The prototype chain is a mechanism in JavaScript that allows objects to inherit properties and methods from other objects. When you try to access a property on an object, JavaScript will first look for the property on the object itself. If it doesn't find it, it will look at the object's prototype, and then the prototype's prototype, and so on, until it either finds the property or reaches the end of the chain, which is `null`."
  },
  {
    "slug": "what-is-the-purpose-of-the-break-and-continue-statements",
    "title": "What is the purpose of the `break` and `continue` statements?",
    "description": "The `break` statement is used to exit a loop or switch statement prematurely, while the `continue` statement skips the current iteration of a loop and proceeds to the next iteration. For example, in a `for` loop, `break` will stop the loop entirely, and `continue` will skip to the next iteration."
  },
  {
    "slug": "what-is-the-purpose-of-the-finally-block",
    "title": "What is the purpose of the `finally` block?",
    "description": "The `finally` block in JavaScript is used to execute code after a `try` and `catch` block, regardless of whether an error was thrown or caught. It ensures that certain cleanup or finalization code runs no matter what. For example:"
  },
  {
    "slug": "what-is-the-purpose-of-the-new-keyword",
    "title": "What is the purpose of the `new` keyword?",
    "description": "The `new` keyword in JavaScript is used to create an instance of a user-defined object type or one of the built-in object types that has a constructor function. When you use `new`, it does four things: it creates a new object, sets the prototype, binds `this` to the new object, and returns the new object."
  },
  {
    "slug": "what-is-the-purpose-of-the-switch-statement",
    "title": "What is the purpose of the `switch` statement?",
    "description": "The `switch` statement is used to execute one block of code among many based on the value of an expression. It is an alternative to using multiple `if...else if` statements. The `switch` statement evaluates an expression, matches the expression's value to a `case` label, and executes the associated block of code. If no `case` matches, the `default` block is executed."
  },
  {
    "slug": "what-is-the-spread-operator-and-how-is-it-used",
    "title": "What is the spread operator and how is it used?",
    "description": "The spread operator, represented by three dots (`...`), is used in JavaScript to expand iterable objects like arrays or strings into individual elements. It can also be used to spread object properties. For example, you can use it to combine arrays, copy arrays, or pass array elements as arguments to a function."
  },
  {
    "slug": "what-is-the-ternary-operator-and-how-is-it-used",
    "title": "What is the ternary operator and how is it used?",
    "description": "The ternary operator is a shorthand for an `if-else` statement in JavaScript. It takes three operands: a condition, a result for true, and a result for false. The syntax is `condition ? expr1 : expr2`. For example, `let result = (a > b) ? 'a is greater' : 'b is greater';` assigns `'a is greater'` to `result` if `a` is greater than `b`, otherwise it assigns `'b is greater'`."
  },
  {
    "slug": "what-is-the-use-of-promiseall",
    "title": "What is the use of `Promise.all()`",
    "description": "`Promise.all()` is a method in JavaScript that takes an array of promises and returns a single promise. This returned promise resolves when all the input promises have resolved, or it rejects if any of the input promises reject. It is useful for running multiple asynchronous operations in parallel and waiting for all of them to complete."
  },
  {
    "slug": "what-is-use-strict-what-are-the-advantages-and-disadvantages-to-using-it",
    "title": "What is `'use strict';` in JavaScript for?",
    "description": "`'use strict'` is a statement used to enable strict mode to entire scripts or individual functions. Strict mode is a way to opt into a restricted variant of JavaScript."
  },
  {
    "slug": "what-language-constructs-do-you-use-for-iterating-over-object-properties-and-array-items",
    "title": "What language constructs do you use for iterating over object properties and array items in JavaScript?",
    "description": "There are multiple ways to iterate over object properties as well as arrays in JavaScript:"
  },
  {
    "slug": "what-tools-and-techniques-do-you-use-for-debugging-javascript-code",
    "title": "What tools and techniques do you use for debugging JavaScript code?",
    "description": "Some of the most commonly used tools and techniques for debugging JavaScript:"
  },
  {
    "slug": "whats-a-typical-use-case-for-anonymous-functions",
    "title": "What's a typical use case for anonymous functions in JavaScript?",
    "description": "Anonymous function in Javascript is a function that does not have any name associated with it. They are typically used as arguments to other functions or assigned to variables."
  },
  {
    "slug": "whats-the-difference-between-a-variable-that-is-null-undefined-or-undeclared-how-would-you-go-about-checking-for-any-of-these-states",
    "title": "What's the difference between a JavaScript variable that is: `null`, `undefined` or undeclared?",
    "description": "| Trait | `null` | `undefined` | Undeclared |\n| --- | --- | --- | --- |\n| Meaning | Explicitly set by the developer to indicate that a variable has no value | Variable has been declared but not assigned a value | Variable has not been declared at all |\n| Type | `object` | `undefined` | Throws a `ReferenceError` |\n| Equality Comparison | `null == undefined` is `true` | `undefined == null` is `true` | Throws a `ReferenceError` |"
  },
  {
    "slug": "whats-the-difference-between-an-attribute-and-a-property",
    "title": "What's the difference between an \"attribute\" and a \"property\" in the DOM?",
    "description": "Attributes are defined in the HTML and provide initial values for properties. Properties are part of the DOM and represent the current state of an element. For example, the `value` attribute of an `<input>` element sets its initial value, while the `value` property reflects the current value as the user interacts with it."
  },
  {
    "slug": "whats-the-difference-between-call-and-apply",
    "title": "What's the difference between `.call` and `.apply` in JavaScript?",
    "description": "`.call` and `.apply` are both used to invoke functions with a specific `this` context and arguments. The primary difference lies in how they accept arguments:"
  },
  {
    "slug": "when-would-you-use-document-write",
    "title": "When would you use `document.write()`?",
    "description": "`document.write()` is rarely used in modern web development because it can overwrite the entire document if called after the page has loaded. It is mainly used for simple tasks like writing content during the initial page load, such as for educational purposes or quick debugging. However, it is generally recommended to use other methods like `innerHTML`, `appendChild()`, or modern frameworks for manipulating the DOM."
  },
  {
    "slug": "why-is-extending-built-in-javascript-objects-not-a-good-idea",
    "title": "Why is extending built-in JavaScript objects not a good idea?",
    "description": "Extending a built-in/native JavaScript object means adding properties/functions to its `prototype`. While this may seem like a good idea at first, it is dangerous in practice. Imagine your code uses a few libraries that both extend the `Array.prototype` by adding the same `contains` method, the implementations will overwrite each other and your code will have unpredictable behavior if these two methods do not work the same way."
  },
  {
    "slug": "why-is-it-in-general-a-good-idea-to-leave-the-global-scope-of-a-website-as-is-and-never-touch-it",
    "title": "Why is it, in general, a good idea to leave the global JavaScript scope of a website as-is and never touch it?",
    "description": "JavaScript that is executed in the browser has access to the global scope (the `window` object). In general it's a good software engineering practice to not pollute the global namespace unless you are working on a feature that truly needs to be global – it is needed by the entire page. Several reasons to avoid touching the global scope:"
  },
  {
    "slug": "why-you-might-want-to-create-static-class-members",
    "title": "Why might you want to create static class members in JavaScript?",
    "description": "Static class members (properties/methods) has a `static` keyword prepended. Such members cannot be directly accessed on instances of the class. Instead, they're accessed on the class itself."
  }
]
